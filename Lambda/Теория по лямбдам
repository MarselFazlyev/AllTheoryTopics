# Лямбда выражение
упрощенная запись анонимного класса, реализующего  **функциональный интерфейс**.
Лямбда-выражение реализует метод, определенный в функциональном интерфейсе.

Локальные переменные использующиеся в лямбдах, должны быть финальными либо эффективно финальными.
**Эффективная финальность**.- это состояние локальной переменной после использования("замыканием " лямбдой). Данную переменную
нельзя изменять после использования в лямбда-выражении! Пример в коде.

### Встроенные функциональные интерфейсы:

#### Имя интерфейса:        Аргументы:        Возвращает    Реализуемый метод

 -Runnable <T>           нет               void          void run ()
-Predicate<T>           Т                 boolean       boolean test(T t)
-Сonsumer<T>            T                 void          void accept (T t)
-Function<T,R>          T                 R             R apply (T t)
-Supplier<T>            нет               T             T get()
-UnaryOperator<T>       T                 T             T apply (T t)
-BinaryOperator<T>      T                 T             T apply (T t1, T t2)

Также можно создать свой функциональный интерфейс,если ни один из встроенных не подходит для решения задачи
(пример есть в презентации по лямбдам Нетологии стр 29).
Можно пометить аннотацией **@Functional Interface**, тогда компилятор не пропустит интерфейс с несколькими методами
без реализации и убережет от ошибки.

**Выведение типов** Начиная с Java 8 можно опускать типы параметров лямбда-выражений. Типы по прежнему проверяются, но явно
указывать нет необходимости. Это называется выыведением типов (аналог,Дженерики, вывод типов в конструкторе).

## Stream API
Лямбда-выражения в потоках Stream API

**Внешнее итерирование** - вызов метода iterator().
Цикл for "синтаксический сахар, скрывающий под капотом итерирование "
На первом шаге вызывается метод iterator(), который создает новый объект Iterator, управляющий процессом итерирования.
Этот механизм называется внешним итерированием. Далее в процессе итерирования явно вызываются методы hasNext и next
объекта Iterator. (Пример в пакете StreamAPI).

Внутреннее итерирование- вызов метода stream() интерфейса Stream. (Пример в пакете StreamAPI)
Существуют промежуточные (отложенные) и терминальные("конечные", "энергичные") методы интерфейса Stream.
Промежуточные операторы строят рецепты обработки Stream, но не приводят к порождению нового значения.
Терминальные операторы, приводят к порождению нового значения последовательности Stream.

Действие  самого потока данных не видоизменяет их источник.(Пример,сортировка данных в потоке не изменяет их
упорядочение в источнике, а скорее приводит к созданию нового потока данных,дающего отсортированный результат.

Во главе иерархии обобщенныц  интерфейс BaseStream<T,extends BaseStream<T,S>> (Т - тип потока данных, расширяющего
интерфейс BaseStream. В свою очередь, интерефейс BaseStream расширяет интрфейс AutoCloseable, а следовательно, потоком
данных можно управлять в блоке оператора try с ресурсами. Закрывать потоки, источниками данных для которых являются
коллекции,не нужно.

Наряду с существованием Stream есть также стримы примитивных данных Intstream extended BaseStream<Integer, IntStream>
Возвращает последовательный упорядоченный IntStream от startInclusive (включительно) до endInclusive (включительно) с шагом приращения 1.
Методы IntStream :
1) Статические :

rangeClosed(int startInclusive, int endInclusive) - Возвращает последовательный упорядоченный IntStream
от startInclusive (включительно) до endInclusive (включительно) с шагом приращения 1.
range       (int startInclusive, int endInclusive)- Возвращает последовательный упорядоченный IntStream
отstartInclusive (включительно) до endInclusive (невключительно)
с шагом приращения 1.
builder()-возвращает билдер, который может добавлять элементы в стрим (IntStream.builder().add(int a).add(int b).build;)
generate (IntSupplier s)  Возвращает бесконечный последовательный неупорядоченный поток, в котором каждый элемент
сгенерирован предоставленным {@code IntSupplier}. Это подходит для
* генерация постоянных потоков, потоков случайных элементов и т.д.



TODO // РАЗОБРАТЬСЯ СО ВСЕМИ МЕТОДАМИ STREAM, ОПИСАТЬ ИХ, ПРОТЕСТИТЬ В КОДЕ.





















Выведение типов -раскрыть понятие стр.27