Примеры взяты из курса Алишева "Продвинутая Джава". Главный поток - main.\
Остальные потоки все будут отпочковываться от главного потока.\
Класс Thread лежит в пакете java.lang\
Программа завершает свое исполнение, когда заканчивают работу все потоки исполнения.

### Способы создания потоков ###

Как можно создать поток (пакет Intro)

1) Можно унаследоваться от класса Thread,потомок будет являться потоком
2) Можно Создать имплементацию интерфейса Runnable,положить объект реализации в конструктор экземпляра класса Thread.
3) Создать пул потоков (ExecutorService) с помощью статического метода класса Executors ExecutorService executorService
   = Executors.newFixedThreadPool(2); // пул из 2 потоков.

### Volatile ###

**volatile** - изменчивый, подверженный изменению.\
Ключевое слово ***volatile***, необходимо когда одна переменная используется несколькими потоками(когда один поток пишет
в эту переменную, один или несколько - читают эту переменную.)\
C помощью volatile можно настроить синхронизацию потоков.\
Проблема когерентности кэшей ядер : когда значение переменной разное в кэшах ядер и информация не синхронна по
переменной.\
Если мы помечаем переменную словом volatile, это значит, что данная переменная не будет кэшироваться, а будет лежать в
общей памяти.(гарантирует когерентность кэшей ядер процессора) (пример в коде).\
Еще одна трактовка: "Что касается volatile переменных, то запись таких переменных производится в основную память, минуя
локальную. и чтение volatile переменной производится также из основной памяти, то есть значение переменной не может
сохраняться в регистрах или локальной памяти потока и операция чтения этой переменной гарантированно вернёт последнее
записанное в неё значение."

### Synchronized ###

Если потоки делят общую переменную и одновременно записывают туда данные, то volatile не подойдет, нужно использовать
ключевое слово **synchrinized** используется в потоках для того, чтобы не было конкуренции в записи у потоков, только
один поток мог работать с телом метода,в котором прописано слово synchronized используется в методах\
Каждому объекту в Java присваивается определенная сущность, и эта сущность в определенный момент времени может быть
только у одного потока. И ключевое слово **synchrinized** использует эту особенность (monitor lock) - только один поток
может завладеть "монитором" одного объекта.

### synchronized block (пример в коде) ###

Блок кода ,ограниченный фигурными скобками в которых прописано synchronized() выполняется строго одним потоком, хотя
остальное тело объемлющего метода может выполняться другими потоками.

### Join ###

Метод join позволяет дождаться окончания работы потока, который вызвал этот метод и продолжить выполнять свою работу в
текущем потоке

### ExecutionService ###

Создание пула потоков применяется, когда необходимо решить задачу много раз или она объемная.

### паттерн Producer-Consumer ###

Паттерн **Producer-Consumer** часто встречается в многопоточном программировании, например при обращении многих
пользователей к серверу. Пользователи играют роль  **producer**(пользователь)(например, отправляют запросы), а сервер **
consumer**(потребитель), например, принимает запросы. Можно реализовать данный паттерн с помощью класса
ArrayBlockingQueue - он находится в пакете java.util.concurrent
(пакет с множеством классов для работы с многопоточностью, все классы Thread-safe (потокобезопасны), к ним можно
обращаться, при этом не возникнет состояние RaceCondition (состояние гонки)).

1. Можно реализовать паттерн **Producer-Consumer** с помощью готового класса ArrayBlockingQueue<>().(Потокобезопасная
   очередь пример Test)
2. Можно реализовать ............................. с помощью методов wait(),notify() (Низкоуровневая реализация паттрна-
   пример Test1)
3. Можно реализовать ............................. с помощью Queue<>(). (Потоконебезопасная очередь пример Test2)

### Wait and Notify ###

методы wait() и notify() вызываются в synchronized блоке.\
При вызове в потоке в синхронизованном блоке метода wait() происходят две вещи:

1) Отдается захваченный монитор (intrinsic lock),как будто мы вышли из синхронизованного блока, если на этом объекте
   синхронизируются также другие потоки,то они могут забрать монитор
2) После вызова метода wait() ожидается вызов метода notify.
3) При вызове метода notify() пробуждается поток, который вызывал wait,в нем будет выполняться дальнейший код.

### Класс CountDownLatch ###

класс из пакета java.util.concurrent, переводится как "защелка обратного отсчета". конструктор экземпляра класса
CountDownLatch принимает число, которое содержит число итераций, после которых "защелка откроется", и поток после
ожидания активируется и продолжает выполнение кода (пример в пакете CountDownLatch ). Cмысл в том, что это число
операций, сколько раз надо вызвать метод countDownLatch.countdown(), чтобы поток больше не ждал.

### Класс ReintrantLock ###
Класс также служит для синхронизации потоков, но у него есть свои преимущества (связанныес Deadlock)





