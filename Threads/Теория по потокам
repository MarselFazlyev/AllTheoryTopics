Примеры взяты из курса Алишева "Продвинутая Джава". Главный поток - main.\
Остальные потоки все будут отпочковываться от главного потока.\
Класс Thread лежит в пакете java.lang\
Программа завершает свое исполнение, когда заканчивают работу все потоки исполнения.

### Способы создания потоков ###

Как можно создать поток (пакет Intro)

1) Можно унаследоваться от класса Thread,потомок будет являться потоком
2) Можно Создать имплементацию интерфейса Runnable,положить объект реализации в конструктор экземпляра класса Thread.
3) Создать пул потоков (ExecutorService) с помощью статического метода класса Executors ExecutorService executorService
   = Executors.newFixedThreadPool(2); // пул из 2 потоков.

### Volatile ###

**volatile** - изменчивый, подверженный изменению.\
Ключевое слово ***volatile***, необходимо когда одна переменная используется несколькими потоками(когда один поток пишет
в эту переменную, один или несколько - читают эту переменную.)\
C помощью volatile можно настроить синхронизацию потоков.\
Проблема когерентности кэшей ядер : когда значение переменной разное в кэшах ядер и информация не синхронна по
переменной.\
Если мы помечаем переменную словом volatile, это значит, что данная переменная не будет кэшироваться, а будет лежать в
общей памяти.(гарантирует когерентность кэшей ядер процессора) (пример в коде).\
Еще одна трактовка: "Что касается volatile переменных, то запись таких переменных производится в основную память, минуя
локальную. и чтение volatile переменной производится также из основной памяти, то есть значение переменной не может
сохраняться в регистрах или локальной памяти потока и операция чтения этой переменной гарантированно вернёт последнее
записанное в неё значение."

### Synchronized ###

Если потоки делят общую переменную и одновременно записывают туда данные, то volatile не подойдет, нужно использовать
ключевое слово **synchrinized** используется в потоках для того, чтобы не было конкуренции в записи у потоков, только
один поток мог работать с телом метода,в котором прописано слово synchronized используется в методах\
Каждому объекту в Java присваивается определенная сущность, и эта сущность в определенный момент времени может быть
только у одного потока. И ключевое слово **synchrinized** использует эту особенность (monitor lock) - только один поток
может завладеть "монитором" одного объекта.

### synchronized block (пример в коде) ###

Блок кода ,ограниченный фигурными скобками в которых прописано synchronized() выполняется строго одним потоком, хотя
остальное тело объемлющего метода может выполняться другими потоками.

### Join ###

Метод join позволяет дождаться окончания работы потока, который вызвал этот метод и продолжить выполнять свою работу в
текущем потоке

### ExecutionService ###

Создание пула потоков применяется, когда необходимо решить задачу много раз или она объемная.

### паттерн Producer-Consumer ###

Паттерн **Producer-Consumer** часто встречается в многопоточном программировании, например при обращении многих
пользователей к серверу. Пользователи играют роль  **producer**(пользователь)(например, отправляют запросы), а сервер **
consumer**(потребитель), например, принимает запросы. Можно реализовать данный паттерн с помощью класса
ArrayBlockingQueue - он находится в пакете java.util.concurrent
(пакет с множеством классов для работы с многопоточностью, все классы Thread-safe (потокобезопасны), к ним можно
обращаться, при этом не возникнет состояние RaceCondition (состояние гонки)).

1. Можно реализовать паттерн **Producer-Consumer** с помощью готового класса ArrayBlockingQueue<>().(Потокобезопасная
   очередь пример Test)
2. Можно реализовать ............................. с помощью методов wait(),notify() (Низкоуровневая реализация паттрна-
   пример Test1)
3. Можно реализовать ............................. с помощью Queue<>(). (Потоконебезопасная очередь пример Test2)

### Wait and Notify ###

методы wait() и notify() вызываются в synchronized блоке.\
При вызове в потоке в синхронизованном блоке метода wait() происходят две вещи:

1) Отдается захваченный монитор (intrinsic lock),как будто мы вышли из синхронизованного блока, если на этом объекте
   синхронизируются также другие потоки,то они могут забрать монитор
2) После вызова метода wait() ожидается вызов метода notify.
3) При вызове метода notify() пробуждается поток, который вызывал wait,в нем будет выполняться дальнейший код.

### Класс CountDownLatch ###

класс из пакета java.util.concurrent, переводится как "защелка обратного отсчета". конструктор экземпляра класса
CountDownLatch принимает число, которое содержит число итераций, после которых "защелка откроется", и поток после
ожидания активируется и продолжает выполнение кода (пример в пакете CountDownLatch ). Cмысл в том, что это число
операций, сколько раз надо вызвать метод **countDownLatch.countdown()**, чтобы поток больше не ждал.

### Класс ReentrantLock ###

Реализует интерфейс Lock с методами **lock**,**unlock**
lock предоставляет только одному потоку "залоченный блок" на выходе из блока, для того чтобы предоставить для
дальнейшего кода доступ, используется метод unlock\
Класс также служит для синхронизации потоков,как и ключевое слово synchronized но у него есть свои преимущества (
связанные с Deadlock - 1) если необходимо захватить несколько мониторов одновременно, то при использовании synchronized
образовывается много вложенносттей,что приводит к увеличению сложности кода. ReentrantLock позволяет избежать этого.

2) в ReentrantLock есть метод tryLock(), который возвращает true/false успешность захвата монитора. С помощью этого
   метода можно спланировать в каком нибудь методе одновременный захват двух мониторов и избежание deadLock(взаимной
   блокировки потоков).

### Semaphore ###

класс Semaphore используется,когда нужно ограничить доступ к ресурсу, используемому множеством потоков. Например
ограничение доступа к серверу, в который пишут 10 потоков.\
Конструктор экземпляра класса Semaphore принимает число ограничений для потоков (Например, если сервер, в котооый пишут
данные, мы можем указать число потоков,которые одновременно могут писать туда данные). нестатические методы \
**acquire()**- декрементирует число разрешений (пропусков) для потоков.\
**release()** - инкрементирует число разрешений (пропусков) для потоков.\
**availablePermits()** - возвращает число доступных разрешений (пропусков) для потоков\
в случае, если на экземпляре семафора число доступных разрешений стало равным нулю, то поток останавливается на
выполнении acquire() и ждет когда на другом потоке будет выполнен release()

### Deadlock (Взаимная блокировка) ###

**Deadlock** - ситуация, когда потоки не выполняют свой код,взаимно ожидая, когда другой поток освободит монитор
объекта, который нужен для выполнения кода текущего потока.\
Способы преодоления - необходимо осуществлять lock (захват мониторов) нескольких объектов в одном и том же порядке).
Если логика программы такова,что захват мониторов необходимо сделать в разном порядке,то в ReentrantLock есть метод
tryLock(), который возвращает true/false успешность захвата монитора. С помощью этого метода можно спланировать в каком
нибудь методе одновременный захват двух мониторов и избежание deadLock(взаимной блокировки потоков).\
Применяя synchronized на нескольких объектах, избежать deadLock в нескольких потоках можно,только если организовать
захват мониторов этих объектов в одном и том же порядке.\
Применяя ReentrantLock, можно избежать DeadLock, даже если осуществляется захват мониторов в разных потоках в разном
порядке.(Пример в пакете DeadLock).

### Прерывание потоков  ###

Interrupted Exception - исключение выбрасывается, когда поток прерывается. Для того, чтобы остановить поток, раньше был
метод **stop()**. Но он помечен аннотацией Deprecated и зачеркнут, так как вызов метода мгновенно "убивает поток" и
выполнение потока зависнет в неопределенном состоянии, например при переводе денег при выполнении stop() деньги зависнут
между счетами.\
Для прерывания выполнения потока используется метод **interrupt()**. Для того, чтобы потоку понять, когда корректно
прерваться, в нем прописывается конструкция **Thread.currentThread().isInterrupted()** и корректное условие
прерывания работы потока.












