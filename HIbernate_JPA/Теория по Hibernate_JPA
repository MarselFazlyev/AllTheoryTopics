## HIbernate,JPA

### JPA - Java Persistence API \

- спецификация, которая описывает общую схему удобного перевода объектов Java в таблицы и наоборот

**Object-Relation Mapping** - перевод "Отображение объектов в таблице " и наоборот.\
**Hibernate** - ORM- библиотека, реализация этого ORM, автоматизирует отображение объектов в таблицы и наоборот.
Преимущество в том,что Hibernate берет на себя написание SQL- запросов для манипуляций с базой данных.\
Чтобы сделать запрос из Hibernate, нам необходимо создать сессию.\
**Сессия** - объект для взаимодействия с Hibernate, когда мы что-то хотим получить из Hibernate, получаем сессию.\
Объект Session получаем из объекта **SessionFactory(паттерн Фабрика)**.\
На объекте Session можно вызывать

- save/persist
- update
- get
- ...

Примеры есть в коде модуля Hibernate

### Транзакция ###

**Транзакция** - единица работы с БД (Начали транзакцию ->работа с БД-> завершили транзакцию)\

Транзакции необходимы для поддержания согласованности данных в таблице\
Транзакции могут блокировать доступ к БД.Примеры :

- пока я пишу в таблицу не читай значения из нее
- пока я обновляю человека его нельзя обновлять
- пока я удаляю строки в таблице нельзя получить все строки из таблицы

Транзакции можно применять (COMMIT) и откатывать (ROLLBACK)
Стандартной проблемой является состояние гонки. Несколько потоков изменяют один и тот же обьект одномоментно - неоходимо
синхронизировать потоки (обычно с помощью блокировок) ->(**Транзакции с разным уровнем изоляции**)

Для того чтобы работать с Hibernate:

1) нужно подключить сам Hibernate и PostgreSQLDriver, так как Hibernate использует
   для своей работы низкоуровневый JDBC.
2) Нужно создать конфигурационный файл **hibernate.properties** (называться должен именно так!!!)-> поместить его в
   папку resources в структуре maven.

В файле **hibernate.properties** необхоимо прописать 2 вещи :

- конфигурацию источника данных (конфигурацию JDBC драйвера)

### Конфигурация источника данных (DataSource)

hibernate.driver_class=org.postgresql.Driver ( JDBC драйвер)
hibernate.connection.url= jdbc:postgreSQL://localhost:5432/hibernate_demo_db (url базы данных)
hibernate.connection.username = postgres
hibernate.connection.password = postgres

- конфигурацию самого Hibernate\

hibernate.dialect= org.hibernate.dialect.PostgreSQLDialect (тип СУБД)
hibernate.show_sql = true (позволяет видеть в консоли , какой запрос SQL сгенерировал Hibernate в базу данных )
hibernate.current_session_context_classes=thread

Kлассы - сущности, с которыми предстоит работать в базе данных с помощью Hibernate,обычно хранятся в папке **model**

## Основные аннотации,применямые Hibernate

1) **@Entity** - указывает,что данный класс является сущностью, и может быть отображен в БД (Между классом с аннотацией
   @Entity и таблицей ,аналогичной названию класса будет связь).

   Все, классы,помеченные аннотацией @Entity, обязательно должны иметь пустой конструктор, и должны иметь хотя бы одно
   поле
   с аннотацией **@Id**.
2) **@Table** - в аргументе данной аннотации прописывается название таблицы, связанной с данным классом (нужна больше
   для
   подстраховки от изменения названия таблицы).
3) **@Column** используется для сопоставления полей класса,помеченного аннотацией @Entity, столбцам в таблице. В
   аргументе аннотации указывается название соответствующего столбца в таблице.
4) **@Id** Над полем "id" должна "навеситься" аннотация @Id. Дает понять Hibernate, что данное поле соответствует
   колонке
   id (первичному ключу) в таблице.
5) **@GeneratedValue** аннотация, которая показывает, что данное поле будет сгенерировано автоматически самой СУБД.
   Необходимо
   в аргументы передать стратегию выбора типа генерируемого значения.

### HQL

**HQL** - был разработан,чтобы мы не спускались до уровня таблиц, а делали запрос, используя наши сущности (Java классы)

1) Конвертируется в SQL
2) В Hibernate можно использовать и обычный SQL для сложных запросов, но лучше HQL.
3) Spring приложение - это обычно комбинация Hibernate(+Spring Data JPA) и SQL для нестандартных запросов
   Основное различие с SQL в том, что HQL использует сущность (Java класс) для запроса в БД (он ничего "не знает" о
   таблицах в БД),никак
   не взаимодействует с БД, а SQL работает напрямую c БД.

### OnetoMany,ManytoOne

используются аннотации **@ManyToOne**,**@OneToMany**\
**@ManyToOne** используется в поле зависимого класса, которое взято из родительского класса (пример в коде). В этом же
поле прописывается аннотация **@JoinColumn** с аргументами названия в таблице и ссылкой на столбец родительского
класса (name = "person_id",referencedColumnName = "id")
**@OneToMany** используется в поле независимого класса, поле которого используется в таблице БД зависимого класса. В
аргументах аннотации используется название поля дочернего класса, которое связано с текущим классом (mappedBy = "owner")
(пример в пакете oneToMany.Person)

Хорошей практикой считается прописывать изменения в объектах с обеих сторон - в базах данных все отобразиться корретно в
любом случае, но если не удалить товары, например у человека, удалив их как таковые, то Hibernate будет оперировать
старой сущностью человека, так как он сохранил его в своем кэше, а обновления инфо не было.

### Жизненный цикл сущности в Hibernate

Java объекты-сущности проходят через несколько состояний, когда мы используем HIbernate:

- **Transient**

1) Объект создан внутри транзакции, но еще не сохранен. Соответственно, пока никак не связан с Hibernate и не
   отслеживается (не находится в так называемом Persistent context)
2) Вызов сеттеров никак не будет влиять на состояние БД
3) Можно воспринимать объект, находящийся в Transient состоянии как обычный Java объект

пример: \
session.beginTransaction();
Person person = new Person("New person",30);
"person" находится в состоянии Transient

- **Persistent(Managed)**
  если выполнить  :

1) session.save(person) или
2) session.get(Person.class,3)\
   то объект(в данном случае - person) переходит в состояние **Persistent** и отслеживается Hibernate -ом
   Объект находится в состоянии persistance до тех пор, пока работает Hibernate сессия\
   Вызов сеттеров на Persistent объектах генерирует SQL код!
   person.setAge(40);

- **Detached**
  Объект перестает быть Persistent и покидает Persistent context - становится опять обычным объектом, который Hibernate
  не отслеживает\
  Это состояние достигается с помощью метода detach() или когда закрывается Hibernate сессия.\
  Можно присоединить объект обратно к Persistence context, если вызвать метод merge().

пример:
// Persistent(Managed)
Person person = session.get(Person.class,3);\
// Это отслеживается Hibernate
person.setAge(25);
// person стал Detached
session.detached(person);
//Это не отслеживается Hibernate
person.setAge(30)

- **Removed**
  Данное состояние возникает при вызове метода **remove**

session.beginTransaction();
//Persistent
Person person = session.get(Person.class,3);
// Removed
session.remove(person);
объект помечен для удаления и следующий commit () удалит соответствующую строку из таблицы.

### Каскадирование

Касадирование необходимо для того, чтобы объекты в кэше Hibernate соответствовали объектам в таблице в Б\Д. Иначе, если
не делать обновление данных в Hibernate c двух сторон, то они устареют и не будут соответствовать себе в Б\Д]

Касадирование - обычно задается для родительской сущности в аргументах (в данном случае в сущности "Person").указывается
аргумент **cascade** и те операции, которые будут каскадироваться вместе с сущностью.
в пакете **cascadirovanie** мы в сущности Person в аннотации @OneToMany указали cascade = cascade.Type.PERSIST".Это
значит, что каскадирование будет производиться только при вызове метода persist. И теперь при сохранении родительской
сущности вместе с ней каскадно будут сохраняться связанные с ней сущности.

## Разница между методами **save()** и **prsisit()**

### Serializable save()

- из самой библиотеки Hibernate, нет у других библиотек JPA
- возвращает значение первичного ключа для добавленной сущности
- гарантирует, что значение первичного ключа будет определено сразу после вызова метода

### void persist()

- из спецификации JPA (Java Persistance API)- любая реализация JPA будет иметь этот метод
- ничего не возвращает
- не гарантирует, что значение первичного ключа будет определено сразу после вызова метода
  Методы очень похожи, в большинстве случаев нет разницы,какой из них использовать.

каскадировать можно много операций, нужные можно перечислить через запятую в аннотации **@Cascade**
самая нужная операция в каскадировании - cascade = CascadeType.PERSIST (каскадирование сохранения объекта в таблице)

### OneToOne

Один к одному, это такие отношения в БД, когда одному объекту в одной таблице может соответствовать только один объект в
другой таблице и наоборот.\
Используемые аннотации:

- @OneToOne
- @JoinColumn

ВНИМАНИЕ!!! Если в качестве первичного ключа используется объект другого класса, необходимо имплементировать интерфейс
Serializable (нужно для Hibernate).

### ManyToMany
- Нет как таковой  owning side,так как ни одна из сущностей не владеет внешним ключом.

Чтобы выстраивать связи manyToMany в Hibernate, нужно использовать две аннотации:
- **@ManyToMany** такая же как и **@ManyToOne** **@OneToOne** (задает связь)
- **@JoinTable** дает понять Hibernate, какая таблица у нас связывающая.
  ( пример заполнения аргументов аннотации: )\
@JoinTable(
- name = )





























